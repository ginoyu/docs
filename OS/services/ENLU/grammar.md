### 离线模板语法
#### 模板文件的构成
模板文件是一个基于特定结构的xml文件。在模板文件中定义了如下几项内容：
* 自定义意图。包括句式，意图名称，参数（槽位）名称，上下文等
* 自定义实体。
* 自定义模糊匹配
* 自定义子模版
##### 意图定义
一个典型的意图定义如下面代码所示：
```xml
<intent input_context="waiting_selection" output_context="start_navi">
    <action value="selection"/>
    <templates>
        <item>$sample_list:sel</item>
    </templates>
    <params>
        <selection>$sel</selection>
    </params>
</intent>
```
上述代码片定义了一个名为selection的意图。此意图的上文为“waiting_selection”，下文是“start_navi”。句式是一个模糊匹配。将匹配项通过名为selection的参数返回。  
这个意图描述了一个在等待用户语音选择候选导航位置，当用户选定之后，开始导航。  
意图定义包含下面几个元素：
* input_context: 该意图的上文
* output_context: 该意图的下文
* action: 意图名称
* template: 句式定义，可以包含多个item
* params: 参数声明。可以包含多个参数。参数取值可以引用句式中定义的槽位。在例子中，名为selection的参数，引用了名为sel的槽位。
##### 自定义实体
实体指在一个句子当中表达特定的含义。一个实体可以是一个地名，标签名，一个数字或者其他自定义的元素。多个实体内容可以映射到一个元素上，称为规约词。自定义实体就是自定义一个map，一个或者多个key（文本内容），对应到一个value（规约词）。  
一个典型的自定义实体的例子如下：
```xml
<entity>
    <function>
        <autoMode>[空调|]智能模式</autoMode>
        <horizontalWind>[空调|]左右摆[风|动|]</horizontalWind>
        <verticalWind>[空调|]上下摆[风|动|]</verticalWind>
        <electricalHeating>[空调|]电加热</electricalHeating>
        <sleepMode>[空调|][睡眠模式|睡觉模式]</sleepMode>
        <airClean>[空调|]空气清新</airClean>
        <windWithPeople>[空调|][风随人动|随动风]</windWithPeople>
        <noPeople>[空调|]无人关机</noPeople>
        <enjoyMode>[空调|]尊享模式</enjoyMode>
    </function>
    <power>
        <on>[开启|开开|打开|开|点|开了|开启|启动]</on>
        <off>[关闭|关上|关了|关|灭了|停止|停了|停掉]</off>
    </power>
</entity>
```
上面定义了多种功能，以及空调电源状态控制指令词。  
其中多个内容可以用|隔开，也可以通过模板句式语法一次性声明多个。句式语法见下。  
自定义了实体，就可以在句式中引用，使用$符号后跟实体名，可以引用实体。  
除了在xml文件中自定义实体之外，还可以在代码中根据数据修改实体的映射表。这种方式而可以解决针对可变数据的实体匹配问题，例如根据动态返回的标签名称配置实体，让用户可以通过语音切换。  
常见的使用实体的方式如下：
```xml
<intent input_context="*">
    <action value="change_mode"/>
    <templates>
        <item>[设置|]$function:func</item>
    </templates>
    <params>
        <mode>$func</mode>
    </params>
</intent>
```
##### 自定义模糊匹配
除了实体之外，很多时候我们面对列表项，希望用户可以不必完全遵照列表内容说全，而是随意说其中的一部分，就可以匹配上。模糊匹配列表项可以解决这个问题。  
一个典型的模糊匹配的定义如下：
```xml
<fuzzy>
    <song_sheet_name>
        <a>默认列表</a>
        <b>巅峰榜内地</b>
        <c>立水桥南|立汤路</c>
        <d>立水桥</d>
    </song_sheet_name>
</fuzzy>
```
上面的代码定义了四个列表项，分别对应a,b,c,d四个规约词。模糊匹配也是一个从列表项到规约词的映射。相同规约词的列表项之间，可以通过|分隔。  
对列表项的引用和实体引用一样，可以在句式中通过$来完成。  
除了在xml文件中预定义好列表项，也可以在运行时通过调用接口来动态修改列表。
##### 自定义子模版
很多时候我们会发现不同的句式中往往包含相同的部分，为了减少重复工作量，我们可以吧这个部分拆分成子模版。  
一个子模版中可以包含实体和匹配项。  
下面是一个自定义子模版的例子：
```xml
<pattern>
    <imperitive>[我要|{[快点|赶紧|马上]|[请[你|]|]}[给我|帮我|帮忙]]</imperitive>
</pattern>
```
##### 自定义元素的层级和搜索关系
上面描述了自定义实体，自定义模糊匹配和自定义子模版，分别对应标签：
* entity: 自定义实体
* fuzzy: 自定义模糊匹配
* pattern: 自定义子模版

此外还有标签用于声明场景，意图，句式，意图名和参数，如下：
* service: 声明一个场景
* intent: 声明一个意图
* action: 声明意图的名称
* templates: 声明意图的句式
* params: 声明意图对应的参数（槽位）

entity等标签可以定义在某个service内，也可以定义在所有service的外面。这决定了它的作用域。定义在service内部的实体，匹配项和子模版，只能被场景自己使用，不能够被定义所在的场景之外的场景使用。定义在所有service的外面，相当于全局定义，可以在任何场景内使用。  

如果有两个不同层级的实体，匹配项和子模版同名，优先使用场景内部定义的那个。
#### 句式定义
##### 多选一
标准格式：[|]  
我们可以定义句式[打开|开始|]播放视频，对应的，用户可以说：“打开播放视频”，“开始播放视频”，或者简单的“播放视频”。  
在多选一中，如果|后面没有任何字符，那么它会被当做一个空串处理。  一个空传出现在多选一的句式中，意味者这个部分可以被省略。
多选一的选项需要用方括号[]包围。
##### 位置可变组合
标准格式：{|}   
我们定义{现在|给我}讲个故事。对应的，用户可以说：现在给我讲个故事，给我现在讲个故事。大括号包围起来的各个部分可以任意组合。但是必须都存在。  
在可变组合中，如果|后面没有定义任何内容，那么它会被当做一个空串。一个空串出现在可变组合中，没有任何影响。
可变组合的选项需要用大括号{}包围。
##### 引用预定义对象
标准格式：$xxx:yyy(min-max)
xxx是预定义单元名称，预定义单元可以是实体，可以是模糊匹配项，可以是子模版。yyy是参数名称，min-max指重复次数。其中参数名称和重复次数都可省略。
重复次数也可写作：
* -4: 最多4次
* 4-: 最少4次
* 4+: 最少4次
* 4: 4次
> 多选一、单选一以及引用预定义对象可以随意嵌套和组合。
##### 预定义实体
预定义匹配项包括三种：
* $sys.date：带日期的时间
* $sys.number：支持小数的数字
* $sys.any：任何内容